<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<title>joyquery - document.querySelector emulator - API reference</title>

	<link rel="stylesheet" href="stylesheets/styles.css">
	<link rel="stylesheet" href="stylesheets/github-light.css">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body>
	<div class="wrapper">
		<header>
			<h1>Joyquery</h1>
			<p>Javascript library implementing emulation of CSS selectors lookup, as document.querySelector.</p>

			<p class="view"><a href="https://github.com/jeremiah-shaulov/joyquery">View the Project on GitHub <small>jeremiah-shaulov/joyquery</small></a></p>

			<ul>
				<li><a href="javascripts/joyquery.js">Download <strong>Source</strong></a></li>
				<li><a href="joyquery.min.js.zip">Download <strong>Minified ZIP</strong></a></li>
				<li><a href="joyquery.min.js.tar.gz">Download <strong>Minified TAR</strong></a></li>
			</ul>

			<div><a href="./">Home</a></div>
			<div><a href="features.html">Features</a></div>
			<div><a href="selectors.html">Selectors</a></div>
			<div><a href="api-reference.html">API reference</a></div>
			<div><a href="adding-extensions.html">Adding extensions</a></div>
			<div><a href="benchmark.html">Benchmark</a></div>
		</header>
		<section>
			

<h2>joyquery - API reference</h2>

<p>The API consists of:</p>

<ul>
<li>function <a href="#joyquery">joyquery()</a></li>
<li><a href="#iterator">iterator function</a> returned by joyquery()</li>
<li><a href="#get">get() function</a></li>
<li>object <a href="#joyquery-functions">joyquery.FUNCTIONS</a></li>
<li><a href="#joyquery-functions">interface</a> for user provided callback functions callable from selectors</li>
<li>and object <a href="#joyquery-settings">joyquery.SETTINGS</a></li>
</ul>

<h2><a name="joyquery"></a>joyquery()</h2>

<pre><code>Iterator function joyquery(string selector, DOMElement context, Object functions, Object override_settings);
</code></pre>

<ul>
<li><strong>selector</strong> - The only mandatory argument. This is the selector to look up.</li>
<li><strong>context</strong> - If provided, will operate only on this element and its descendants. If not provided, document.documentElement (the &lt;html&gt; tag) is used.</li>
<li><strong>functions</strong> - object containing functions, callable from the selector, in addition to global <a href="#joyquery-functions">joyquery.FUNCTIONS</a>.</li>
<li><strong>override_settings</strong> - settings that override those in global <a href="#joyquery-settings">joyquery.SETTINGS</a>.</li>
</ul>

<p>The joyquery() function returns another function, which is iterator.</p>

<h2><a name="iterator"></a>iterator()</h2>

<pre><code>DOMElement function iterator();
</code></pre>

<p>Each call to the iterator function causes to search for next element. The found element will be returned, or if there are no more results, null is returned. Subsequent calls will do nothing.</p>

<pre><code>for (var elem, it=joyquery("a.cls"); elem=it();)
{   console.log(elem);
}
</code></pre>

<p>The iterator function (it()) has method get().</p>

<h2><a name="get"></a>get()</h2>

<pre><code>Array function get(); // [1]
DOMElement function get(Number index); // [2]
Array function get(index, count); // [3]
</code></pre>

<p>The [1]st form iterates over all results and returns the results as Array of DOMElement. Even if built-in querySelectorAll() was used, which returns non-array collection (in Chrome it is NodeList), get() always returns Array object.</p>

<p>Example:</p>

<pre><code>var all_results = joyquery("a.cls").get();
</code></pre>

<p>The [2]nd form returns single result whoose number is provided. Can return null (or undefined).</p>

<p>Example:</p>

<pre><code>var elem = joyquery("a.cls").get(0);
</code></pre>

<p>The [3]rd form returns slice Array from the result set.</p>

<p>Example:</p>

<pre><code>var results = joyquery("a.cls").get(10, 3);
</code></pre>

<h2><a name="querySelector"></a>Conditions for built-in optimization</h2>

<p>If browser is equiped with built-in element.querySelector and element.querySelectorAll functions, they will get a try to handle the supplied selector.</p>

<pre><code>var all_results = joyquery("a.cls").get(); // querySelectorAll is tried
var some_results = joyquery("a.cls").get(10, 3); // querySelectorAll is tried
var elem = joyquery("a.cls").get(0); // querySelector is tried
var results = joyquery("a.cls").get(0, 1); // querySelector is tried
</code></pre>

<p>Though there is option not to utilize built-in functions. See <a href="#emulate">joyquery.SETTINGS</a>.</p>

<h2>Duplicate elements in result</h2>

<p>When iterating through result of a selector that contains alternatives (commas), the same element can be returned several times.</p>

<pre><code>for (var elem, it=joyquery("div a, div &gt; span &gt; a"); elem=it();)
{   console.log(elem);
}
</code></pre>

<p>This can happen only when result is not stored to array. When you use get() to store the result to an array, only unique elements are returned.</p>

<pre><code>var all_results = joyquery("div a, div &gt; span &gt; a").get();
</code></pre>

<h2><a name="joyquery-functions"></a>joyquery.FUNCTIONS and Javascript callback functions</h2>

<p>If selector contains a pseudo-class (like :contains-word-Hello) which is not implemented by joyquery library, joyquery will look for Javascript function to handle it. Dashes in the name are substituted with underscores.</p>

<p>First, if "functions" argument (the 3rd argument) was provided for joyquery(), and it is an object that has such function (method), this function is called.</p>

<p>If there was no function provided, the function will be looked in global joyquery.FUNCTIONS object.</p>

<p>Adding methods to this global object will extend joyquery functionality.</p>

<p>The extension functions are called in context of some object that has the following properties:</p>

<ul>
<li><strong>this.node</strong> - The current DOMElement to test.</li>
<li><strong>this.document</strong> - The document to which the element belongs.</li>
<li><strong>this.window</strong> - The window to which the document belongs.</li>
<li><strong>this.position</strong> - Function that returns 0-based position of this element inside it's parent. Only DOMElement nodes are counted, not text or comments. If first argument to this.position() is true, will count only elements that have the same name as current element.</li>
<li><strong>this.last</strong> - Function that returns number of DOMElement nodes (not text or comments) inside current element's parent. If first argument to this.last() is true, will count only elements that have the same name as current element.</li>
<li><strong>this.FUNCTIONS</strong> - the global joyquery.FUNCTIONS of current joyquery.</li>
<li><strong>this.functions</strong> - the functions passed to joyquery as 3rd argument.</li>
</ul>

<p>Extension function must return true if it considers the current element (this.node) to be matching.</p>

<pre><code>var elements = joyquery
(   "div &gt; p:contains-word-Hello", null,
    {   contains_word_Hello: function()
        {   return (this.node.textContent || this.node.innerText || '').indexOf('Hello') != -1;
        }
    }
).get();
</code></pre>

<p>Extension functions can recieve arguments. If a selector passed as argument (like in :has() or :not() functions), then the extension function will recieve object that has two methods: evaluate(node) and evaluate_one(node).</p>

<p>This is implementation of :has(selector) handler:</p>

<pre><code>var elements = joyquery
(   "div:my-custom-has(* p)", null,
    {   my_custom_has: function(selector)
        {   return selector.evaluate(this.node).get(0);
        }
    }
).get();
</code></pre>

<p>Method evaluate_one(node) is optimized version of evaluate(node) that returns first found node.</p>

<pre><code>var elements = joyquery
(   "div:my-custom-has(* p)", null,
    {   my_custom_has: function(selector)
        {   return selector.evaluate_one(this.node);
        }
    }
).get();
</code></pre>

<h2><a name="joyquery-settings"></a>joyquery.SETTINGS</h2>

<p>This global object contains settings that affect joyquery operation. There are 2 settings:</p>

<ul>
<li><a href="#compiler_cache_max">compiler_cache_max</a> - default value is 4</li>
<li><a href="#emulate">emulate</a> - default value is false</li>
</ul>

<p><a name="compiler_cache_max"></a> <strong>compiler_cache_max</strong> specifies for how many selectors to store compiler result. Each time you call joyquery() with selectors that built-in document.querySelector() can't handle, joyquery() needs to parse the selector and convert it to internal commands. These commands are stored in compiler cache for further reuse. So next time joyquery() will not need to reparse the same selector, if you query it several times (maybe in loop).</p>

<p>The default value 4 means there will be up to 4 compiler results stored in memory permanently.</p>

<p>jQuery also has compiler cache.</p>

<p>Example:</p>

<pre><code>joyquery.SETTINGS.compiler_cache_max = 1;
var subelems = joyquery('child::*', elem);
</code></pre>

<p>The joyquery() function also has 4th argument that overrides global settings during current call.</p>

<p>Example:</p>

<pre><code>var subelems = joyquery('child::*', elem, null, {compiler_cache_max: 1});
</code></pre>

<p><a name="emulate"></a><strong>emulate</strong> - if set to true, joyquery() will not try to utilize built-in document.querySelector() and document.querySelectorAll() functions.</p>

<p>This is rarely needed. One of possible reasons is to avoid calling document.querySelector() for selectors where it will fail for sure.</p>

<p>Another reason is to test joyquery emulation performance.</p>

<p>Example:</p>

<pre><code>joyquery.SETTINGS.emulate = true;
var subelems = joyquery('child::*', elem);
</code></pre>

<p>Example:</p>

<pre><code>var subelems = joyquery('child::*', elem, null, {emulate: true});
</code></pre>

<p>Though there can be one more theoretic reason. Utilization of built-in function means that all the results will be found at once and stored in array. You may not want this. For example in case that there are much more results than you are planning to iterate over. Or maybe if you are willing to modify DOM tree between the calls to iterator, and thus affecting the further search.</p>
		</section>
		<footer>
			<p>This project is maintained by <a href="https://github.com/jeremiah-shaulov">jeremiah-shaulov</a></p>
			<p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
		</footer>
    </div>
	<script src="javascripts/scale.fix.js"></script>
</body>
</html>
